// Code generated by ogen, DO NOT EDIT.

package oas

import (
	"net/http"

	"github.com/go-faster/errors"

	"github.com/ogen-go/ogen/conv"
	"github.com/ogen-go/ogen/middleware"
	"github.com/ogen-go/ogen/uri"
	"github.com/ogen-go/ogen/validate"
)

// DnsBackResolveParams is parameters of dnsBackResolve operation.
type DnsBackResolveParams struct {
	// Account ID.
	AccountID string
}

func unpackDnsBackResolveParams(packed middleware.Parameters) (params DnsBackResolveParams) {
	{
		key := middleware.ParameterKey{
			Name: "account_id",
			In:   "path",
		}
		params.AccountID = packed[key].(string)
	}
	return params
}

func decodeDnsBackResolveParams(args [1]string, r *http.Request) (params DnsBackResolveParams, _ error) {
	// Decode path: account_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "account_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.AccountID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: account_id: parse")
			}
		} else {
			return params, errors.New("path: account_id: not specified")
		}
	}
	return params, nil
}

// DnsResolveParams is parameters of dnsResolve operation.
type DnsResolveParams struct {
	// Domain name with .ton or .t.me.
	DomainName string
}

func unpackDnsResolveParams(packed middleware.Parameters) (params DnsResolveParams) {
	{
		key := middleware.ParameterKey{
			Name: "domain_name",
			In:   "path",
		}
		params.DomainName = packed[key].(string)
	}
	return params
}

func decodeDnsResolveParams(args [1]string, r *http.Request) (params DnsResolveParams, _ error) {
	// Decode path: domain_name.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "domain_name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.DomainName = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: domain_name: parse")
			}
		} else {
			return params, errors.New("path: domain_name: not specified")
		}
	}
	return params, nil
}

// ExecGetMethodParams is parameters of execGetMethod operation.
type ExecGetMethodParams struct {
	// Account ID.
	AccountID string
	// Contract get method name.
	MethodName string
}

func unpackExecGetMethodParams(packed middleware.Parameters) (params ExecGetMethodParams) {
	{
		key := middleware.ParameterKey{
			Name: "account_id",
			In:   "path",
		}
		params.AccountID = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "method_name",
			In:   "path",
		}
		params.MethodName = packed[key].(string)
	}
	return params
}

func decodeExecGetMethodParams(args [2]string, r *http.Request) (params ExecGetMethodParams, _ error) {
	// Decode path: account_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "account_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.AccountID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: account_id: parse")
			}
		} else {
			return params, errors.New("path: account_id: not specified")
		}
	}
	// Decode path: method_name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "method_name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.MethodName = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: method_name: parse")
			}
		} else {
			return params, errors.New("path: method_name: not specified")
		}
	}
	return params, nil
}

// GetAccountParams is parameters of getAccount operation.
type GetAccountParams struct {
	// Account ID.
	AccountID string
}

func unpackGetAccountParams(packed middleware.Parameters) (params GetAccountParams) {
	{
		key := middleware.ParameterKey{
			Name: "account_id",
			In:   "path",
		}
		params.AccountID = packed[key].(string)
	}
	return params
}

func decodeGetAccountParams(args [1]string, r *http.Request) (params GetAccountParams, _ error) {
	// Decode path: account_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "account_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.AccountID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: account_id: parse")
			}
		} else {
			return params, errors.New("path: account_id: not specified")
		}
	}
	return params, nil
}

// GetAccountTransactionsParams is parameters of getAccountTransactions operation.
type GetAccountTransactionsParams struct {
	// Account ID.
	AccountID string
	// Omit this parameter to get last transactions.
	MaxLt OptInt64
	// Omit this parameter to get last transactions.
	MinLt OptInt64
	Limit OptInt32
}

func unpackGetAccountTransactionsParams(packed middleware.Parameters) (params GetAccountTransactionsParams) {
	{
		key := middleware.ParameterKey{
			Name: "account_id",
			In:   "path",
		}
		params.AccountID = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "max_lt",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.MaxLt = v.(OptInt64)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "min_lt",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.MinLt = v.(OptInt64)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "limit",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Limit = v.(OptInt32)
		}
	}
	return params
}

func decodeGetAccountTransactionsParams(args [1]string, r *http.Request) (params GetAccountTransactionsParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: account_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "account_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.AccountID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: account_id: parse")
			}
		} else {
			return params, errors.New("path: account_id: not specified")
		}
	}
	// Decode query: max_lt.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "max_lt",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotMaxLtVal int64
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt64(val)
					if err != nil {
						return err
					}

					paramsDotMaxLtVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.MaxLt.SetTo(paramsDotMaxLtVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: max_lt: parse")
			}
		}
	}
	// Decode query: min_lt.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "min_lt",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotMinLtVal int64
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt64(val)
					if err != nil {
						return err
					}

					paramsDotMinLtVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.MinLt.SetTo(paramsDotMinLtVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: min_lt: parse")
			}
		}
	}
	// Set default value for query: limit.
	{
		val := int32(100)
		params.Limit.SetTo(val)
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int32
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt32(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
			if err := func() error {
				if params.Limit.Set {
					if err := func() error {
						if err := (validate.Int{
							MinSet:        false,
							Min:           0,
							MaxSet:        true,
							Max:           1000,
							MinExclusive:  false,
							MaxExclusive:  false,
							MultipleOfSet: false,
							MultipleOf:    0,
						}).Validate(int64(params.Limit.Value)); err != nil {
							return errors.Wrap(err, "int")
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: limit: invalid")
			}
		}
	}
	return params, nil
}

// GetAllAuctionsParams is parameters of getAllAuctions operation.
type GetAllAuctionsParams struct {
	// Domain filter for current auctions "ton" or "t.me".
	Tld OptString
}

func unpackGetAllAuctionsParams(packed middleware.Parameters) (params GetAllAuctionsParams) {
	{
		key := middleware.ParameterKey{
			Name: "tld",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Tld = v.(OptString)
		}
	}
	return params
}

func decodeGetAllAuctionsParams(args [0]string, r *http.Request) (params GetAllAuctionsParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: tld.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "tld",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTldVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotTldVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Tld.SetTo(paramsDotTldVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: tld: parse")
			}
		}
	}
	return params, nil
}

// GetBlockParams is parameters of getBlock operation.
type GetBlockParams struct {
	// Block ID.
	BlockID string
}

func unpackGetBlockParams(packed middleware.Parameters) (params GetBlockParams) {
	{
		key := middleware.ParameterKey{
			Name: "block_id",
			In:   "path",
		}
		params.BlockID = packed[key].(string)
	}
	return params
}

func decodeGetBlockParams(args [1]string, r *http.Request) (params GetBlockParams, _ error) {
	// Decode path: block_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "block_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.BlockID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: block_id: parse")
			}
		} else {
			return params, errors.New("path: block_id: not specified")
		}
	}
	return params, nil
}

// GetDomainBidsParams is parameters of getDomainBids operation.
type GetDomainBidsParams struct {
	// Domain name with .ton or .t.me.
	DomainName string
}

func unpackGetDomainBidsParams(packed middleware.Parameters) (params GetDomainBidsParams) {
	{
		key := middleware.ParameterKey{
			Name: "domain_name",
			In:   "path",
		}
		params.DomainName = packed[key].(string)
	}
	return params
}

func decodeGetDomainBidsParams(args [1]string, r *http.Request) (params GetDomainBidsParams, _ error) {
	// Decode path: domain_name.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "domain_name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.DomainName = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: domain_name: parse")
			}
		} else {
			return params, errors.New("path: domain_name: not specified")
		}
	}
	return params, nil
}

// GetEventParams is parameters of getEvent operation.
type GetEventParams struct {
	// Event ID or transaction hash in hex (without 0x) or base64url format.
	EventID string
}

func unpackGetEventParams(packed middleware.Parameters) (params GetEventParams) {
	{
		key := middleware.ParameterKey{
			Name: "event_id",
			In:   "path",
		}
		params.EventID = packed[key].(string)
	}
	return params
}

func decodeGetEventParams(args [1]string, r *http.Request) (params GetEventParams, _ error) {
	// Decode path: event_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "event_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.EventID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: event_id: parse")
			}
		} else {
			return params, errors.New("path: event_id: not specified")
		}
	}
	return params, nil
}

// GetEventsByAccountParams is parameters of getEventsByAccount operation.
type GetEventsByAccountParams struct {
	// Account ID.
	AccountID string
	// Omit this parameter to get last events.
	BeforeLt  OptInt64
	Limit     int
	StartDate OptInt64
	EndDate   OptInt64
}

func unpackGetEventsByAccountParams(packed middleware.Parameters) (params GetEventsByAccountParams) {
	{
		key := middleware.ParameterKey{
			Name: "account_id",
			In:   "path",
		}
		params.AccountID = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "before_lt",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.BeforeLt = v.(OptInt64)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "limit",
			In:   "query",
		}
		params.Limit = packed[key].(int)
	}
	{
		key := middleware.ParameterKey{
			Name: "start_date",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.StartDate = v.(OptInt64)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "end_date",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.EndDate = v.(OptInt64)
		}
	}
	return params
}

func decodeGetEventsByAccountParams(args [1]string, r *http.Request) (params GetEventsByAccountParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: account_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "account_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.AccountID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: account_id: parse")
			}
		} else {
			return params, errors.New("path: account_id: not specified")
		}
	}
	// Decode query: before_lt.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "before_lt",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotBeforeLtVal int64
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt64(val)
					if err != nil {
						return err
					}

					paramsDotBeforeLtVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.BeforeLt.SetTo(paramsDotBeforeLtVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: before_lt: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.Limit = c
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
			if err := func() error {
				if err := (validate.Int{
					MinSet:        false,
					Min:           0,
					MaxSet:        true,
					Max:           1000,
					MinExclusive:  false,
					MaxExclusive:  false,
					MultipleOfSet: false,
					MultipleOf:    0,
				}).Validate(int64(params.Limit)); err != nil {
					return errors.Wrap(err, "int")
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: limit: invalid")
			}
		} else {
			return params, errors.Wrap(err, "query")
		}
	}
	// Decode query: start_date.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "start_date",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotStartDateVal int64
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt64(val)
					if err != nil {
						return err
					}

					paramsDotStartDateVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.StartDate.SetTo(paramsDotStartDateVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: start_date: parse")
			}
		}
	}
	// Decode query: end_date.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "end_date",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotEndDateVal int64
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt64(val)
					if err != nil {
						return err
					}

					paramsDotEndDateVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.EndDate.SetTo(paramsDotEndDateVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: end_date: parse")
			}
		}
	}
	return params, nil
}

// GetJettonInfoParams is parameters of getJettonInfo operation.
type GetJettonInfoParams struct {
	// Account ID.
	AccountID string
}

func unpackGetJettonInfoParams(packed middleware.Parameters) (params GetJettonInfoParams) {
	{
		key := middleware.ParameterKey{
			Name: "account_id",
			In:   "path",
		}
		params.AccountID = packed[key].(string)
	}
	return params
}

func decodeGetJettonInfoParams(args [1]string, r *http.Request) (params GetJettonInfoParams, _ error) {
	// Decode path: account_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "account_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.AccountID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: account_id: parse")
			}
		} else {
			return params, errors.New("path: account_id: not specified")
		}
	}
	return params, nil
}

// GetJettonsBalancesParams is parameters of getJettonsBalances operation.
type GetJettonsBalancesParams struct {
	// Account ID.
	AccountID string
}

func unpackGetJettonsBalancesParams(packed middleware.Parameters) (params GetJettonsBalancesParams) {
	{
		key := middleware.ParameterKey{
			Name: "account_id",
			In:   "path",
		}
		params.AccountID = packed[key].(string)
	}
	return params
}

func decodeGetJettonsBalancesParams(args [1]string, r *http.Request) (params GetJettonsBalancesParams, _ error) {
	// Decode path: account_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "account_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.AccountID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: account_id: parse")
			}
		} else {
			return params, errors.New("path: account_id: not specified")
		}
	}
	return params, nil
}

// GetNftCollectionParams is parameters of getNftCollection operation.
type GetNftCollectionParams struct {
	// Account ID.
	AccountID string
}

func unpackGetNftCollectionParams(packed middleware.Parameters) (params GetNftCollectionParams) {
	{
		key := middleware.ParameterKey{
			Name: "account_id",
			In:   "path",
		}
		params.AccountID = packed[key].(string)
	}
	return params
}

func decodeGetNftCollectionParams(args [1]string, r *http.Request) (params GetNftCollectionParams, _ error) {
	// Decode path: account_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "account_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.AccountID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: account_id: parse")
			}
		} else {
			return params, errors.New("path: account_id: not specified")
		}
	}
	return params, nil
}

// GetNftCollectionsParams is parameters of getNftCollections operation.
type GetNftCollectionsParams struct {
	Limit  OptInt32
	Offset OptInt32
}

func unpackGetNftCollectionsParams(packed middleware.Parameters) (params GetNftCollectionsParams) {
	{
		key := middleware.ParameterKey{
			Name: "limit",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Limit = v.(OptInt32)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "offset",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Offset = v.(OptInt32)
		}
	}
	return params
}

func decodeGetNftCollectionsParams(args [0]string, r *http.Request) (params GetNftCollectionsParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Set default value for query: limit.
	{
		val := int32(15)
		params.Limit.SetTo(val)
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int32
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt32(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
			if err := func() error {
				if params.Limit.Set {
					if err := func() error {
						if err := (validate.Int{
							MinSet:        false,
							Min:           0,
							MaxSet:        true,
							Max:           25,
							MinExclusive:  false,
							MaxExclusive:  false,
							MultipleOfSet: false,
							MultipleOf:    0,
						}).Validate(int64(params.Limit.Value)); err != nil {
							return errors.Wrap(err, "int")
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: limit: invalid")
			}
		}
	}
	// Set default value for query: offset.
	{
		val := int32(0)
		params.Offset.SetTo(val)
	}
	// Decode query: offset.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "offset",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotOffsetVal int32
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt32(val)
					if err != nil {
						return err
					}

					paramsDotOffsetVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Offset.SetTo(paramsDotOffsetVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: offset: parse")
			}
		}
	}
	return params, nil
}

// GetNftItemByAddressParams is parameters of getNftItemByAddress operation.
type GetNftItemByAddressParams struct {
	// Account ID.
	AccountID string
}

func unpackGetNftItemByAddressParams(packed middleware.Parameters) (params GetNftItemByAddressParams) {
	{
		key := middleware.ParameterKey{
			Name: "account_id",
			In:   "path",
		}
		params.AccountID = packed[key].(string)
	}
	return params
}

func decodeGetNftItemByAddressParams(args [1]string, r *http.Request) (params GetNftItemByAddressParams, _ error) {
	// Decode path: account_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "account_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.AccountID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: account_id: parse")
			}
		} else {
			return params, errors.New("path: account_id: not specified")
		}
	}
	return params, nil
}

// GetNftItemsByOwnerParams is parameters of getNftItemsByOwner operation.
type GetNftItemsByOwnerParams struct {
	// Account ID.
	AccountID string
}

func unpackGetNftItemsByOwnerParams(packed middleware.Parameters) (params GetNftItemsByOwnerParams) {
	{
		key := middleware.ParameterKey{
			Name: "account_id",
			In:   "path",
		}
		params.AccountID = packed[key].(string)
	}
	return params
}

func decodeGetNftItemsByOwnerParams(args [1]string, r *http.Request) (params GetNftItemsByOwnerParams, _ error) {
	// Decode path: account_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "account_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.AccountID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: account_id: parse")
			}
		} else {
			return params, errors.New("path: account_id: not specified")
		}
	}
	return params, nil
}

// GetRawAccountParams is parameters of getRawAccount operation.
type GetRawAccountParams struct {
	// Account ID.
	AccountID string
}

func unpackGetRawAccountParams(packed middleware.Parameters) (params GetRawAccountParams) {
	{
		key := middleware.ParameterKey{
			Name: "account_id",
			In:   "path",
		}
		params.AccountID = packed[key].(string)
	}
	return params
}

func decodeGetRawAccountParams(args [1]string, r *http.Request) (params GetRawAccountParams, _ error) {
	// Decode path: account_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "account_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.AccountID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: account_id: parse")
			}
		} else {
			return params, errors.New("path: account_id: not specified")
		}
	}
	return params, nil
}

// GetSubscriptionsByAccountParams is parameters of getSubscriptionsByAccount operation.
type GetSubscriptionsByAccountParams struct {
	// Account ID.
	AccountID string
}

func unpackGetSubscriptionsByAccountParams(packed middleware.Parameters) (params GetSubscriptionsByAccountParams) {
	{
		key := middleware.ParameterKey{
			Name: "account_id",
			In:   "path",
		}
		params.AccountID = packed[key].(string)
	}
	return params
}

func decodeGetSubscriptionsByAccountParams(args [1]string, r *http.Request) (params GetSubscriptionsByAccountParams, _ error) {
	// Decode path: account_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "account_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.AccountID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: account_id: parse")
			}
		} else {
			return params, errors.New("path: account_id: not specified")
		}
	}
	return params, nil
}

// GetTraceParams is parameters of getTrace operation.
type GetTraceParams struct {
	// Trace ID or transaction hash in hex (without 0x) or base64url format.
	TraceID string
}

func unpackGetTraceParams(packed middleware.Parameters) (params GetTraceParams) {
	{
		key := middleware.ParameterKey{
			Name: "trace_id",
			In:   "path",
		}
		params.TraceID = packed[key].(string)
	}
	return params
}

func decodeGetTraceParams(args [1]string, r *http.Request) (params GetTraceParams, _ error) {
	// Decode path: trace_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "trace_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.TraceID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: trace_id: parse")
			}
		} else {
			return params, errors.New("path: trace_id: not specified")
		}
	}
	return params, nil
}

// GetTracesByAccountParams is parameters of getTracesByAccount operation.
type GetTracesByAccountParams struct {
	// Account ID.
	AccountID string
	Limit     OptInt32
}

func unpackGetTracesByAccountParams(packed middleware.Parameters) (params GetTracesByAccountParams) {
	{
		key := middleware.ParameterKey{
			Name: "account_id",
			In:   "path",
		}
		params.AccountID = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "limit",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Limit = v.(OptInt32)
		}
	}
	return params
}

func decodeGetTracesByAccountParams(args [1]string, r *http.Request) (params GetTracesByAccountParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: account_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "account_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.AccountID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: account_id: parse")
			}
		} else {
			return params, errors.New("path: account_id: not specified")
		}
	}
	// Set default value for query: limit.
	{
		val := int32(100)
		params.Limit.SetTo(val)
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int32
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt32(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
			if err := func() error {
				if params.Limit.Set {
					if err := func() error {
						if err := (validate.Int{
							MinSet:        false,
							Min:           0,
							MaxSet:        true,
							Max:           1000,
							MinExclusive:  false,
							MaxExclusive:  false,
							MultipleOfSet: false,
							MultipleOf:    0,
						}).Validate(int64(params.Limit.Value)); err != nil {
							return errors.Wrap(err, "int")
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: limit: invalid")
			}
		}
	}
	return params, nil
}

// GetTransactionParams is parameters of getTransaction operation.
type GetTransactionParams struct {
	// Transaction ID.
	TransactionID string
}

func unpackGetTransactionParams(packed middleware.Parameters) (params GetTransactionParams) {
	{
		key := middleware.ParameterKey{
			Name: "transaction_id",
			In:   "path",
		}
		params.TransactionID = packed[key].(string)
	}
	return params
}

func decodeGetTransactionParams(args [1]string, r *http.Request) (params GetTransactionParams, _ error) {
	// Decode path: transaction_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "transaction_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.TransactionID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: transaction_id: parse")
			}
		} else {
			return params, errors.New("path: transaction_id: not specified")
		}
	}
	return params, nil
}

// GetTransactionsParams is parameters of getTransactions operation.
type GetTransactionsParams struct {
	// Block ID.
	BlockID string
}

func unpackGetTransactionsParams(packed middleware.Parameters) (params GetTransactionsParams) {
	{
		key := middleware.ParameterKey{
			Name: "block_id",
			In:   "path",
		}
		params.BlockID = packed[key].(string)
	}
	return params
}

func decodeGetTransactionsParams(args [1]string, r *http.Request) (params GetTransactionsParams, _ error) {
	// Decode path: block_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "block_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.BlockID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: block_id: parse")
			}
		} else {
			return params, errors.New("path: block_id: not specified")
		}
	}
	return params, nil
}

// PoolsByNominatorsParams is parameters of poolsByNominators operation.
type PoolsByNominatorsParams struct {
	// Account ID.
	AccountID string
}

func unpackPoolsByNominatorsParams(packed middleware.Parameters) (params PoolsByNominatorsParams) {
	{
		key := middleware.ParameterKey{
			Name: "account_id",
			In:   "path",
		}
		params.AccountID = packed[key].(string)
	}
	return params
}

func decodePoolsByNominatorsParams(args [1]string, r *http.Request) (params PoolsByNominatorsParams, _ error) {
	// Decode path: account_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "account_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.AccountID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: account_id: parse")
			}
		} else {
			return params, errors.New("path: account_id: not specified")
		}
	}
	return params, nil
}

// StackingPoolInfoParams is parameters of stackingPoolInfo operation.
type StackingPoolInfoParams struct {
	// Account ID.
	AccountID string
}

func unpackStackingPoolInfoParams(packed middleware.Parameters) (params StackingPoolInfoParams) {
	{
		key := middleware.ParameterKey{
			Name: "account_id",
			In:   "path",
		}
		params.AccountID = packed[key].(string)
	}
	return params
}

func decodeStackingPoolInfoParams(args [1]string, r *http.Request) (params StackingPoolInfoParams, _ error) {
	// Decode path: account_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "account_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.AccountID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: account_id: parse")
			}
		} else {
			return params, errors.New("path: account_id: not specified")
		}
	}
	return params, nil
}

// StackingPoolsParams is parameters of stackingPools operation.
type StackingPoolsParams struct {
	// Account ID.
	AvailableFor OptString
	// Return also pools not from white list - just compatible by interfaces (maybe dangerous!).
	IncludeUnverified OptBool
}

func unpackStackingPoolsParams(packed middleware.Parameters) (params StackingPoolsParams) {
	{
		key := middleware.ParameterKey{
			Name: "available_for",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.AvailableFor = v.(OptString)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "include_unverified",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.IncludeUnverified = v.(OptBool)
		}
	}
	return params
}

func decodeStackingPoolsParams(args [0]string, r *http.Request) (params StackingPoolsParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: available_for.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "available_for",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAvailableForVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotAvailableForVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AvailableFor.SetTo(paramsDotAvailableForVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: available_for: parse")
			}
		}
	}
	// Decode query: include_unverified.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "include_unverified",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotIncludeUnverifiedVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotIncludeUnverifiedVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.IncludeUnverified.SetTo(paramsDotIncludeUnverifiedVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: include_unverified: parse")
			}
		}
	}
	return params, nil
}
